/*
 * mfp.c - Atari ST Multi-Function Peripheral MFP 68901
 *
 * Limited implementation of interrupt handling and timers
 * (The RS232 part is done independently in usart.c) 
 *
 * Part of STonC (C) 1998-2002 Laurent Vogel
 * Covered by the GPL version 2 or later; see COPYING for details
 */

#define DO_TIMERD_ALARM 1

/*
 * Notes
 * -----
 *
 * For clarity, every internal register values are private (static). Following
 * actual ST inner architecture, there are two ways to access to MFP data :
 * 1) from the 68000 processor, functions mfp_set_xxx and mfp_get_xxx;
 * 2) from inside hardware (e.g. interrupt requests), specific functions.
 * Using direct memory addresses, as in "LM_UB(MEM(0xFFFA01))" will not give
 * access to the MFP. 
 *
 *
 * Interrupts
 * ----------
 *
 * Peripherals (acia, dma, ...) are connected to the MFP like this :
 *
 *    -------------+         IRQ*          +-------------- 
 *      peripheral |---------------------->|   MFP 68901   
 *                 |                       |
 *
 * IRQ* is a signal generated by the peripheral, connected to one of MFP 
 * inputs I0 to I7 (corresponding to GPIP bits).
 * The peripheral usually signals an interrupt by having IRQ* go from 1 to 0.
 * Then the MFP determines whether to raise an interrupt, which eventually 
 * is followed by action on the peripheral. The peripheral then acknowledges
 * by having IRQ* go back to 1. Modification of IRQ* value is done using 
 * function mfp_set_gpip_bits(). 
 *
 * Interrupts are requested by calling function mfp_ask_interrupt(). If this
 * interrupt is accepted by MFP (interrupt active and not masked), an 
 * exception will eventually occur (for instance when a higher priority
 * interruption resumes). This is signalled by setting flag F_MFP, meaning 
 * that IRQ level 6 is requested. When IRQ 6 is accepted by the CPU, function
 * mfp_do_interrupt() is called, returning a vector number for this exception.
 *
 * Since the vector returned by MFP_do_interrupt() corresponds to the highest 
 * priority MFP interrupt request pending at the time MFP_do_interrupt() is
 * called, there is no need to keep F_MFP high, even if lower priority MFP
 * interrupts remain pending. The flag will be set again if needed when
 * this interrupts ends (when the corresponding ISR bit is set back to 0).
 *
 * 
 * Timers
 * ------
 *
 * Timers implementation is based on virtual time. The module vtime.c 
 * maintains a countinuously increasing numeric value called virtual time, or
 * Atari time. This time is supposed to correspond to a nonintegral number of 
 * seconds since the Atari ST was powered up. In practice time is increased 
 * after completing mc68000 instructions, by an amount that is periodically 
 * adjusted so that virtual time stays close to real time (see vtime.c).
 *
 * Only delay mode is implemented for the four timers: given a frequency 
 * divisor and a counter value, the timer implementation sets a vtime alarm 
 * to the moment when the counter will have reached zero. The launching time 
 * is also kept so that one can compute a value of the counter if that counter
 * is being read during a timer cycle. 
 *
 * When the timer alarm is ringed, the corresponding interrupt is requested, 
 * and the timer is launched again (another vtime alarm is set). If the timer
 * is stopped the next alarm is cancelled if any (clear_alarm()).
 *
 * As a special case, timer D also decrements USART (RS232) counters to 
 * simulate transmission and/or reception of bits. When usart counters reach 
 * zero, the timer D alarm calls corresponding usart alarms (see usart.c).
 *
 * TODO
 * ----
 *
 * - modifying ier, imr or ipr should have impact on F_MFP (It gets 
 *   correct eventually thanks to timer C regular interrupts ?)
 * - systematic check against official Motorola Documentation
 */


#include <stdio.h>
#include <stdlib.h>
#include "emulc.h"
#include "vtime.h"
#include "defs.h"
#include "usart.h"
#include "mfp.h"

static struct mfp_registers {
        unsigned short mfp_input ;      /* input lines connected to gpip */
        unsigned short mfp_gpip ;       /* General purpose i/o port */
        unsigned short mfp_aer ;                /* active edge register */
        unsigned short mfp_ddr ;                /* data direction register */
/* vector register ; bit 7-4 : vector ; bit 3: interrupt mode */
        unsigned short mfp_vr ;
#define MFP_VR_VECTOR 0xF0 
#define MFP_VR_SEI 0x08         /* Software end of interrupt, 
                                need software cancelling in isr(a|b) ? */
#define MFP_VR_AEI 0x00         /* Automatic end of interrupt,
                                ??? */
/* timer A, B, CD control registers */
        unsigned short mfp_tacr ;       
        unsigned short mfp_tbcr ;       
        unsigned short mfp_tcdcr ;      
/* timer A, B, C, D data registers */
        unsigned short mfp_tadr ;       
        unsigned short mfp_tbdr ;       
        unsigned short mfp_tcdr ;       
        unsigned short mfp_tddr ;
/* private registers : */
        unsigned int mfp_ier ;
        unsigned int mfp_ipr ;
        unsigned int mfp_isr ;
        unsigned int mfp_imr ;
} mfp ;

/*
  prototypes
 */

void mfp_set_gpip_bit(unsigned char mask, unsigned char value) ;
void mfp_reset(void) ;
void mfp_init(void) ;

/* called when ier is altered, to see if we need to
 * launch an alarm for a timer
 */
static void mfp_check_timers_ier(void);


/*
  link with memory registers 

  I personally prefer naming things than using their number. 
*/

#if 0
#define D_MEM_LINK(_adr,_reg) \
  unsigned char mfp_get_ ## _reg(void) ; \
  unsigned char LOAD_B_ ## _adr (void) { \
    unsigned char v = mfp_get_ ## _reg() ; \
    ec_stderr( "0x%08lx -> 0x%02x\n", 0x ## _adr, v) ; \
    return v ; \
  } \
  void mfp_set_ ## _reg (unsigned char v) ; \
  void STORE_B_ ## _adr (unsigned char v) { \
    ec_stderr( "0x%08lx <- 0x%02x\n", 0x ## _adr, v) ; \
    mfp_set_ ## _reg(v) ; \
  }
#else
#define D_MEM_LINK(_adr,_reg) \
  unsigned char mfp_get_ ## _reg(void) ; \
  unsigned char LOAD_B_ ## _adr (void) { \
    unsigned char v = mfp_get_ ## _reg() ; \
    ec_stderr( " mfp_" #_reg " -> 0x%02x\n", v) ; \
    return v ; \
  } \
  void mfp_set_ ## _reg (unsigned char v) ; \
  void STORE_B_ ## _adr (unsigned char v) { \
    ec_stderr( "mfp_" #_reg " <- 0x%02x\n", v) ; \
    mfp_set_ ## _reg(v) ; \
  }
#endif

#define MEM_LINK(_adr,_reg) \
  unsigned char mfp_get_ ## _reg(void) ; \
  unsigned char LOAD_B_ ## _adr (void) { \
    return mfp_get_ ## _reg() ; \
  } \
  void mfp_set_ ## _reg (unsigned char v) ; \
  void STORE_B_ ## _adr (unsigned char v) { \
    mfp_set_ ## _reg(v) ; \
  }

/* replace by D_MEM_LINK(...,...) to trace activity */
#if 0
#define MEM_LINK(a,b) D_MEM_LINK(a,b)
#endif

MEM_LINK (fffa01, gpip)    /* General Purpose I/O Port */
MEM_LINK (fffa03, aer)     /* Active Edge Register */
MEM_LINK (fffa05, ddr)     /* Data Direction Register */
MEM_LINK (fffa07, iera)    /* Interrupt Enable Register A */
MEM_LINK (fffa09, ierb)    /* IER B */
MEM_LINK (fffa0b, ipra)    /* Interrupt Pending Register A */
MEM_LINK (fffa0d, iprb)    /* IPR B */
MEM_LINK (fffa0f, isra)    /* Interrupt in Service Register A */
MEM_LINK (fffa11, isrb)    /* ISR B */
MEM_LINK (fffa13, imra)    /* Interrupt Mask Register A */
MEM_LINK (fffa15, imrb)    /* IMR B */
MEM_LINK (fffa17, vr)      /* Vector Register */
MEM_LINK (fffa19, tacr)    /* Timer A Control Register */
MEM_LINK (fffa1b, tbcr)    /* Timer B Control Register */
MEM_LINK (fffa1d, tcdcr)   /* Timers C & D Control Register */
MEM_LINK (fffa1f, tadr)    /* Timer A Data Register */
MEM_LINK (fffa21, tbdr)    /* Timer B Data Register */
MEM_LINK (fffa23, tcdr)    /* Timer C Data Register */
MEM_LINK (fffa25, tddr)    /* Timer D Data Register */


static void mfp_init_timers(void) ;
static void mfp_reset_timers(void) ;


#define MODE_MONO        0
extern int gr_mode;
extern int shiftmod;
static int have_switched=0;

void mfp_reset(void)
{
  /* TODO : query value for mfp.mfp_input */
  
#if 1
  if (gr_mode == MODE_MONO) 
#else
        /* allow switching between mono/color */
        if ((!have_switched && gr_mode == MODE_MONO) || shiftmod == 2)
#endif
        {
          have_switched = 1;
          mfp.mfp_input = 0x7f;
        } else {
          mfp.mfp_input = 0xff;
        }

/*
[HC901UM.pdf]
During a device reset condition, all internal MFP registers are cleared except 
for the timer data registers (TADR, TBDR, TCDR, and TDDR), the USART data 
register (UDR), and the transmitter status register (TSR). All timers are stopped, 
the USART receiver and transmitter are disabled, and the serial output (SO) line 
is placed in high impedance. The interrupt channels are also disabled and any 
pending interrupts are cleared. In addition, the general purpose interrupt
I/O lines are placed in the high-impedance input mode, and the timer outputs 
are driven low. External MFP signals are negated.
*/

  mfp.mfp_gpip = mfp.mfp_input;
  mfp.mfp_aer = 0 ;
  mfp.mfp_ddr = 0 ;
  mfp.mfp_ier = 0 ;
  mfp.mfp_ipr = 0 ;
  mfp.mfp_isr = 0 ;
  mfp.mfp_imr = 0 ;
  mfp.mfp_vr = 0 ;
  mfp.mfp_tacr = 0 ;
  mfp.mfp_tbcr = 0 ;
  mfp.mfp_tcdcr = 0 ;

  mfp_reset_timers() ;
  usart_reset() ;
  
  flags &= ~F_MFP;

#if 0
  /* done */
  ec_stderr( "mfp reset\n") ;
#endif
}


void mfp_init(void)
{
  /* 
     initialize files, (serial port, etc)
     ...
   */
#if 0
  ec_stderr( "mfp init\n") ;
#endif
  mfp_init_timers() ;
  usart_init() ;

  mfp_reset() ;
}

/* 
   Interrupts

   register access methods 
*/


/* prototypes */

void mfp_set_gpip(unsigned char val) ;
void mfp_set_aer(unsigned char val) ;
void mfp_set_ddr(unsigned char val) ;
void mfp_set_iera(unsigned char val) ;
void mfp_set_ierb(unsigned char val) ;
void mfp_set_ipra(unsigned char val) ;
void mfp_set_iprb(unsigned char val) ;
void mfp_set_isra(unsigned char val) ;
void mfp_set_isrb(unsigned char val) ;
void mfp_set_imra(unsigned char val) ;
void mfp_set_imrb(unsigned char val) ;
void mfp_set_vr(unsigned char val) ;

unsigned char mfp_get_gpip(void) ;
unsigned char mfp_get_aer(void) ;
unsigned char mfp_get_ddr(void) ;
unsigned char mfp_get_iera(void) ;
unsigned char mfp_get_ierb(void) ;
unsigned char mfp_get_ipra(void) ;
unsigned char mfp_get_iprb(void) ;
unsigned char mfp_get_isra(void) ;
unsigned char mfp_get_isrb(void) ;
unsigned char mfp_get_imra(void) ;
unsigned char mfp_get_imrb(void) ;
unsigned char mfp_get_vr(void) ;


static int map_gpip_to_ier[8] = {0, 1, 2, 3, 6, 7, 14, 15} ;    

void mfp_set_gpip(unsigned char new_gpip) 
{
  mfp.mfp_gpip &= ~mfp.mfp_ddr ;
  mfp.mfp_gpip |= new_gpip & mfp.mfp_ddr ;
}

void mfp_set_aer(unsigned char val) 
{ 
  /* AER : 1=Rising (0->1), 0=Falling (1->0) */
  
  /* [mfp.txt]
   * The edge bit is simply one input to an exclusive-or
   * gate, with the other input coming from the input buffer and the output going
   * to a 1-0 transition detector. Thus, depending upon the state of the input,
   * writing the AER can cause an interrupt-producing transition
   */
  /* this means : a = input xor aer, and interrupt when a 1->0.
   *  ____before____ ______after_____ ___result___
   *  input  aer  a   input  val  a    interrupt
   *    0     0   0     0     1   1      
   *    1     0   1     1     1   0       yes
   *    0     1   1     0     0   0       yes
   *    1     1   0     1     0   1      
   */
  int i, j;
  for(j = 0, i = 1 ; j < 8 ; j++, i <<= 1) {
    if( ((mfp.mfp_aer & i) != (val & i))        /* if AER changes */
        && (! (mfp.mfp_ddr & i))                /* for input lines */
        && ((mfp.mfp_aer & i) != (mfp.mfp_input & i))) {
      mfp_ask_interrupt(map_gpip_to_ier[j]) ;
    }
  }
  mfp.mfp_aer = val ; 
}

void mfp_set_ddr(unsigned char val) 
{ 
  /* DDR : 1=Output, 0=Input */
  mfp.mfp_ddr = val ; 
  mfp.mfp_gpip &= mfp.mfp_ddr;
  mfp.mfp_gpip |= mfp.mfp_input & (~mfp.mfp_ddr);
  /* It is not known whether changing the DDR can cause 
   * an interrupt 
   */
}


#define SET_HIGH(a,v) ((a) &= 0xFF, (a) |= ((val) << 8))
#define SET_LOW(a,v) ((a) &= 0xFF00, (a) |= (val))

void mfp_set_iera(unsigned char val) 
{       
  SET_HIGH(mfp.mfp_ier,val) ;
  /* cancel any pending interrupts, but do not alter ISR. */
  mfp.mfp_ipr &= mfp.mfp_ier ;
  mfp_check_timers_ier();
}

void mfp_set_ierb(unsigned char val) 
{
  SET_LOW(mfp.mfp_ier,val) ;
  /* cancel any pending interrupts */
  mfp.mfp_ipr &= mfp.mfp_ier ;
  mfp_check_timers_ier();
}

void mfp_set_ipra(unsigned char val) 
{
  /* [mfp.txt]
   * IPRA and IPRB are also writeable and a pending interrupt can be cleared
   * without going through the acknowledge sequence by writing a zero to the
   * appropriate bit. This allows any one bit to be cleared, without altering any
   * other bits, simply by writing all ones except for the bit position to be
   * cleared on IPRA or IPRB.
   */
  mfp.mfp_ipr &= (val<<8) | 0xFF ;
  /* if no unmasked interrupt pending any more, there's no point in 
   * keeping F_MFP active 
   */
  if((mfp.mfp_ipr & mfp.mfp_imr) == 0) {
    flags &= ~F_MFP;
  }
}

void mfp_set_iprb(unsigned char val) 
{
  mfp.mfp_ipr &= (val&0xff) | 0xFF00 ;
  if((mfp.mfp_ipr & mfp.mfp_imr) == 0) {
    flags &= ~F_MFP;
  }
}

void mfp_set_isra(unsigned char val) 
{
  /* [mfp.txt]
   * Only a zero may be written into any bit of ISRA and ISRB; thus the 
   * in-service may be cleared in software but cannot be set in software.
   */
  mfp.mfp_isr &= (val<<8) | 0xFF ;
#if 0
  ec_stderr( "ier %04x, ipr %04x, isr %04x, imr %04x\n",
          mfp.mfp_ier, mfp.mfp_ipr, mfp.mfp_isr, mfp.mfp_imr) ;
#endif

  if(mfp.mfp_ipr & mfp.mfp_imr) {
    /* unmasked interrupt pending, signal it to cpu */
    flags |= F_MFP ;
  }

}

void mfp_set_isrb(unsigned char val) 
{
  mfp.mfp_isr &= (val & 0xFF) | 0xFF00 ;
#if 0
  ec_stderr( "ier %04x, ipr %04x, isr %04x, imr %04x\n",
          mfp.mfp_ier, mfp.mfp_ipr, mfp.mfp_isr, mfp.mfp_imr) ;
#endif
  if(mfp.mfp_ipr & mfp.mfp_imr) {
    /* unmasked interrupt pending, signal it to cpu */
    flags |= F_MFP ;
  }
}

void mfp_set_imra(unsigned char val) 
{
  SET_HIGH(mfp.mfp_imr,val) ;
  if(mfp.mfp_ipr & mfp.mfp_imr) {
    flags |= F_MFP ;
  } else {
    flags &= ~F_MFP ;
  }
}

void mfp_set_imrb(unsigned char val) 
{
  SET_LOW(mfp.mfp_imr,val) ;
  if(mfp.mfp_ipr & mfp.mfp_imr) {
    flags |= F_MFP ;
  } else {
    flags &= ~F_MFP ;
  }
}

void mfp_set_vr(unsigned char val) 
{
  mfp.mfp_vr = val ;
  /* test the S bit */
  if(mfp.mfp_vr & 0x08) { 
    /* software end-of-interrupt mode */
  } else {
    /* automatic end-of-interrupt mode : reset isr bits ? */
    mfp.mfp_isr = 0;
    /* try to pass a vector */
    if(mfp.mfp_ipr & mfp.mfp_imr) {
      flags |= F_MFP ;
    } else {
      flags &= ~F_MFP ;
    }
  }
}

unsigned char mfp_get_gpip(void) { return mfp.mfp_gpip ; }
unsigned char mfp_get_aer(void) { return mfp.mfp_aer ; }
unsigned char mfp_get_ddr(void) { return mfp.mfp_ddr ; }

unsigned char mfp_get_iera(void) { return mfp.mfp_ier >> 8 ;   }
unsigned char mfp_get_ierb(void) { return mfp.mfp_ier & 0xFF ; }
unsigned char mfp_get_ipra(void) { return mfp.mfp_ipr >> 8 ;   }
unsigned char mfp_get_iprb(void) { return mfp.mfp_ipr & 0xFF ; }
unsigned char mfp_get_isra(void) { return mfp.mfp_isr >> 8 ;   }
unsigned char mfp_get_isrb(void) { return mfp.mfp_isr & 0xFF ; }
unsigned char mfp_get_imra(void) { return mfp.mfp_imr >> 8 ;   }
unsigned char mfp_get_imrb(void) { return mfp.mfp_imr & 0xFF ; }

unsigned char mfp_get_vr(void) { return mfp.mfp_vr ; }



/*
   mfp_set_gpip_bit

   mfp_set_gpip is called when processor wants to set output port bits.
   use mfp_set_gpip_bit for input port bits (peripheral INTR*) 
*/

void mfp_set_gpip_bit(unsigned char mask, unsigned char value) 
{
  /* here we determine whether to raise an exception */
  
  int i, j ;
  int old_gpip = mfp.mfp_gpip ;
  int new_gpip ;
        
  mask &= 0xFF ;
  mfp.mfp_input &= ~mask;
  mfp.mfp_input |= (value & mask) ;
  
#if 0
  if(mask == 0x10) {
     /* ACIA */
    ec_stderr( "set_gpip_bit(0x%02x, 0x%02x)\n", mask,  value & 0xFF) ;
    ec_stderr( "gpip = 0x%02x, input = 0x%02x, ", mfp.mfp_gpip, mfp.mfp_input);
    ec_stderr( "aer = 0x%02x, ddr = 0x%02x\n", mfp.mfp_aer, mfp.mfp_ddr);
  }
#endif 
  /* if output port, no interrupt */
  mask &= ~mfp.mfp_ddr ;

  new_gpip = old_gpip & ~mask ;
  new_gpip |= (value & mask) ;
  
  mfp.mfp_gpip = new_gpip & 0xFF ;

  for(j = 0, i = 1 ; j < 8 ; j++, i <<= 1) {
    if((old_gpip & i) != (new_gpip & i)) {
      if (mfp.mfp_aer & i) {
        /* interrupt when going from 0 to 1  */
        if(old_gpip & i)
          continue ;
      }
      else {
        /* interrupt when going from 1 to 0  */
        if(new_gpip & i)
          continue;
      }
      mfp_ask_interrupt(map_gpip_to_ier[j]) ;
    }
  }     
}




/*
        Ask for an interrupt. Depending on diverse factors, an
        interrupt will eventually occur the next time 
        mfp_do_interrupt() is called. 
*/
        
void mfp_ask_interrupt(int int_level) 
{
  unsigned int i;

#if 0
        int verbose = 0;
        switch(int_level) {
        case 0: verbose = 0; break;  /* IO port 0 : Printer ? */
        case 1: verbose = 1; break;  /* IO port 1 : RS232 Carrier detect */
        case 2: verbose = 1; break;  /* IO port 2 : RS232 CTS */
        case 3: verbose = 0; break;  /* IO port 3 : Blitter */
        case 4: verbose = 0; break;  /* timer D */
        case 5: verbose = 1; break;  /* timer C */
        case 6: verbose = 1; break;  /* IO port 4 : ACIA (KBD/MIDI) */
        case 7: verbose = 0; break;  /* IO port 5 : FDC/DMA */
        case 8: verbose = 0; break;  /* Timer B */
        case 9: verbose = 1; break;  /* Send error */
        case 10: verbose = 1; break; /* Send buffer empty */
        case 11: verbose = 1; break; /* Receive error */
        case 12: verbose = 1; break; /* Receive buffer full */
        case 13: verbose = 0; break; /* Timer A */ 
        case 14: verbose = 1; break; /* IO port 6 : RS232 ring*/
        case 15: verbose = 0; break; /* IO port 7 : monochrome detect*/
        }

        if(verbose) {
        ec_stderr( "mfp ask interrupt %d\n", int_level) ;

        ec_stderr( "ier %04x, ipr %04x, isr %04x, imr %04x\n",
               mfp.mfp_ier, mfp.mfp_ipr, mfp.mfp_isr, mfp.mfp_imr) ;
        }
#endif


        i = 1 << int_level ;
        /* interrupt enabled ? */
        if( (mfp.mfp_ier & i) == 0)
                return ;
        /* same interrupt already pending */
        if( (mfp.mfp_ipr & i) )
                return ;
        
        
        /* ok, we will request an interrupt to the mfp */
#if 0
        if(int_level) {
          ec_stderr( "mfp ask interrupt %d\n", int_level) ;
        }
#endif
        mfp.mfp_ipr |= i ;
        /* interrupt masked ? */
        if( ! (mfp.mfp_imr & i) ) {
                /* ipr set but no irq : stop here */
          return ;
        }
                /* highest priority ? */
        if(mfp.mfp_isr > i) {
                /* no, do nothing (the mfp whill check when the current
                  interrupt resumes, i.e. when isr is being cleared). */
                return ;
        }
        /* say we want to interrupt the cpu */  
        flags |= F_MFP ;
        /* when cpu.c finds this flag set, according to the current IPL,
          the function mfp_do_interrupt() will be called. This function 
          will then decide what to do, and will treat the request that 
          has the highest priority at that time. 
        */
        
}

/* return : vector number, or zero if no interrupt */
int mfp_do_interrupt(void) 
{
        int j, vector ;
        unsigned i;
        
        /* what's happening here ? */
#if 0
        ec_stderr( "starting mfp_do_interrupt\n") ;
        ec_stderr( "ier %04x, ipr %04x, isr %04x, imr %04x\n",
               mfp.mfp_ier, mfp.mfp_ipr, mfp.mfp_isr, mfp.mfp_imr) ;
#endif
        /* any pending interrupts? */
        
        for(j = 15, i = 0x8000 ; i ; j--, i>>=1) {
                if(mfp.mfp_ipr & i & mfp.mfp_imr)
                        break ;
        }
        if(i == 0) {
          /* this shouldn't happen :-) */
                ec_stderr( "mfp_do_interrupt called "
                        "with no pending interrupt\n") ;
                flags &= ~F_MFP ;
                return 0 ;
        }
        if(mfp.mfp_isr >= i) {
                /* Still busy. We shouldn't come here. */
                ec_stderr( "mfp_do_interrupt called when "
                        "another higher priority interrupt is running\n") ;
                flags &= ~F_MFP ;
                return 0 ;
        }
        
        /* ok, do the interrupt, i.e. "pass the vector". */
        vector = (mfp.mfp_vr & 0xF0) + j ;
        mfp.mfp_ipr &= ~i ;
        flags &= ~F_MFP ;

        if(mfp.mfp_vr & MFP_VR_SEI) {
                /* software mode of interrupt : isr will remain set until
                   explicitely cleared by writing on it */
                mfp.mfp_isr |= i ;
        } else {
                /* automatic mode of interrupt : isr automatically cleared
                   when the interrupt starts (which is now). In this case,
                   we must keep the flag raised if another unmasked 
                   interrupt remains pending, since isr will not tell us 
                   to re-raise the flag.
                */
                if((mfp.mfp_ipr & mfp.mfp_imr)) {
                  /* if other unmasked interrupt pending, keep the flag */
                  flags |= F_MFP ;
                }
        }

#if 0
        ec_stderr( "mfp_do_interrupt : vector %d\n", vector) ;
#endif
        return vector ;
}       
        
        

/******************************** Timers *******************************/

/*
 * Timers
 * 
 * Timers are messy. 
 *
 * TODO:
 *
 * - reset timers A and B ;
 * - timers A and B pulse and count mode.
 * - distinguish between timer counter and data register
 * - do not set an alarm if there is no corresponding interrupt.
 * - for Timer D, do not set an alarm only for the usart, tell
 *   the usart to manage its alarms.
 */

#define get_atari_time() vt_get_etime()

/* prototypes */
        
void mfp_set_tacr(unsigned char val) ;
void mfp_set_tbcr(unsigned char val) ;
void mfp_set_tcdcr(unsigned char val) ;
void mfp_set_tadr(unsigned char val) ;
void mfp_set_tbdr(unsigned char val) ;
void mfp_set_tcdr(unsigned char val) ;
void mfp_set_tddr(unsigned char val) ;

unsigned char mfp_get_tacr(void) ;
unsigned char mfp_get_tbcr(void) ;
unsigned char mfp_get_tcdcr(void) ;
unsigned char mfp_get_tadr(void) ;
unsigned char mfp_get_tbdr(void) ;
unsigned char mfp_get_tcdr(void) ;
unsigned char mfp_get_tddr(void) ;

static int timer_divide[] = {0, 4, 10, 16, 50, 64, 100, 200} ;

typedef struct mfp_timer_info {
  /* the period of the input signal for the timer. */
  /* normally 1 / the MFP clock frequency, except for HBL counts, or */
  /* other weird usages (not supported yet) */
  double period;
  /* the frequency division factor, = the period multiplication factor. */
  int divide;
  /* the address of the data register */
  unsigned short *data_reg;
  /* the number of the interrupt associated to this timer */
  int int_level;
  /* the value of the counter reg. The actual timer period is */
  /* period * divide * counter_value */
  unsigned short counter_value;
  /* the time in seconds when the timer was launched */
  double last_time;
  /* the timer is active */
  int timer_on;
  /* there is an alarm for this timer */
  int alarm_on;
} mfp_timer_info ;

static struct mfp_timer_info mfp_timers[4] ;

static void timer_alarm(void *timer_num) ;
static void launch_timer(long timer_num) ;
static void stop_timer(long timer_num) ;


static void mfp_check_timers_ier(void)
{
  int timer_num;
  struct mfp_timer_info *p;
  for(timer_num = 0 ; timer_num < 4 ; timer_num++) {
    p = &mfp_timers[timer_num];
    if(!p->timer_on) continue;
    if(mfp.mfp_ier & (1 << p->int_level)) {
      if(! p->alarm_on) {
        /* need to set an alarm to catch the next interrupt. */
        double t;  /* remaining time */
        double now = get_atari_time() ;
        double fraction, decr ;
        unsigned short data;
        
        fraction = (now - p->last_time) / (p->period * p->divide) ;
        decr = p->counter_value * fraction ;
        *(p->data_reg) = data = p->counter_value - decr +1 ;
        
        t = p->period * p->divide * data - (now - p->last_time);
        set_alarm(t, timer_alarm, (void *)timer_num) ;
        p->alarm_on = 1;
      }
    } else {
      if(p->alarm_on) {
        /* no need for the alarm now that the interrupt is 
         * not requested 
         */
        clear_alarm(timer_alarm, (void *)timer_num);
        p->alarm_on = 0;
      }
    }
  }
}

static void launch_timer(long timer_num) 
{
  struct mfp_timer_info *p = &mfp_timers[timer_num] ;
  unsigned short data = *(p->data_reg) ;
  double t ;

  if(data == 0)
    data = 256 ;

  t = p->period * p->divide * data ;
  p->counter_value = data ;

  p->timer_on = 1 ;
  p->last_time = get_atari_time() ;
  
#if 0
  ec_stderr( "launching timer %c : \n", (int)  timer_num + 'A') ;
  ec_stderr( "  period after division %f, counter value %d\n",
          (double) (p->period * p->divide), p->counter_value) ;
  ec_stderr( "  now : %f, delay = %f, next time = %f\n", 
          p->last_time, t, p->last_time+t) ;
#endif

/* only set an alarm if the interrupt is allowed. */
  if((mfp.mfp_ier & (1 << p->int_level))) {
    p->alarm_on = 1;
#if 0
    {
      char name[10] ;
      sprintf(name, "timer %c", (int) timer_num + 'A') ;
      set_alarm_name(t, timer_alarm, (void *)timer_num, name) ;
    }
#else
    set_alarm(t, timer_alarm, (void *)timer_num) ;
#endif
  }
}

static void stop_timer(long timer_num) 
{
  struct mfp_timer_info *p = &mfp_timers[timer_num] ;
#if 0
  ec_stderr( "stop timer %c\n", (int) timer_num + 'A');
#endif 
  if(p->alarm_on) {
    clear_alarm(timer_alarm, (void *)timer_num);
  }
  p->alarm_on = 0;
  p->timer_on = 0;
}


static void timer_alarm(void * timer_num_void)
{
  int timer_num = (int) timer_num_void;
        struct mfp_timer_info *p = &mfp_timers[timer_num];
        double t = p->period * p->divide * p->counter_value;

        if(!p->timer_on) {
          ec_stderr( "timer %c alarm : stopped timer\n", timer_num + 'A');
          return;
        }
        mfp_ask_interrupt(p->int_level);
        * (p->data_reg) = p->counter_value;
        if(p->counter_value == 0) {
          p->timer_on = 0;
          return;
        }

        p->last_time = get_atari_time();

#if 0
        if(timer_num < 3)
        {
          char name[10] ;
          sprintf(name, "timer %c", timer_num + 'A') ;
          set_alarm_name(t, timer_alarm, (void *)timer_num, name) ;
        } else {
          set_alarm(t, timer_alarm, (void *)timer_num) ;
        }
#else
        set_alarm(t, timer_alarm, (void *)timer_num) ;
#endif
        
#if 0
        if(timer_num == 3) {
          if (usart_rc_count >0) {
            usart_rc_count -- ;
            if(usart_rc_count == 0) {
              usart_rc_alarm() ;
            }
          }
          if (usart_tr_count >0) {
            usart_tr_count -- ;
            if(usart_tr_count == 0) {
              usart_tr_alarm() ;
            }
          }
        }
#endif
}

void mfp_set_tacr(unsigned char val) 
{
        mfp_timer_info *p = &mfp_timers[0] ;
        val &= 0x0F ;
        if(val == mfp.mfp_tacr)
                return ;
        if(val & MFP_TIMER_PULSE) {
                /* don't know what pulse mode means */
                ec_stderr( "timer A pulse or count mode ignored \n") ;
                val = 0 ;
        }
        /* stop the timer anyway */
        stop_timer(0) ;
        if(val != 0) {
                p->int_level = MFP_INT_TIMERA ;
                p->period = TIMER_A_PERIOD ;
                p->divide = timer_divide[val] ;
                p->data_reg = &mfp.mfp_tadr ;
                
                launch_timer(0) ;
        }
        mfp.mfp_tacr = val ;
}

void mfp_set_tbcr(unsigned char val) 
{
        mfp_timer_info *p = &mfp_timers[1] ;
        val &= 0x0F ;
        if(val == mfp.mfp_tbcr)
                return ;
        if(val & MFP_TIMER_PULSE) {
                /* don't know what pulse mode means */
                ec_stderr( "timer B pulse or count mode ignored \n") ;
                val = 0 ;
        }
        /* stop the timer anyway */
        stop_timer(1) ;
        if(val != 0) {
                p->int_level = MFP_INT_TIMERB ;
                p->period = TIMER_B_PERIOD ;
                p->divide = timer_divide[val] ;
                p->data_reg = &mfp.mfp_tbdr ;
                
                launch_timer(1) ;
        }
        mfp.mfp_tacr = val ;
}


void mfp_set_tcdcr(unsigned char val) 
{
        int val_c, val_d ;
        val_c = (val & 0x70)>>4 ;
        val_d = val & 0x7 ;
        if(val_c != ((mfp.mfp_tcdcr & 0x70)>>4)) {
                /* stop the timer anyway */
                stop_timer(2) ;
                if((val_c != 0) && (mfp.mfp_tcdr >= 1)) {
                        mfp_timer_info *p = &mfp_timers[2] ;
                        p->int_level = MFP_INT_TIMERC ;
                        p->period = TIMER_C_PERIOD ;
                        p->divide = timer_divide[val_c] ;
                        p->data_reg = &mfp.mfp_tcdr ;
                        launch_timer(2) ;
                }
        }
        if(val_d != (mfp.mfp_tcdcr & 0x7)) {
                /* stop the timer anyway */
                stop_timer(3) ;
                usart_stop_timer_d();
                if((val_d != 0) && (mfp.mfp_tddr >= 1) ) {
                        mfp_timer_info *p = &mfp_timers[3] ;
                        p->int_level = MFP_INT_TIMERD ;
                        p->period = TIMER_D_PERIOD ;
                        p->divide = timer_divide[val_d] ;
                        p->data_reg = &mfp.mfp_tddr ;
                        launch_timer(3) ;
                  usart_start_timer_d(p->period * p->divide * mfp.mfp_tddr);
                }
        }
        mfp.mfp_tcdcr = val & 0x77 ;    
}

void mfp_set_tadr(unsigned char val) 
{
  mfp_timer_info *p = &mfp_timers[0] ;
  p->counter_value = val ;
  mfp.mfp_tadr = val ;
}

void mfp_set_tbdr(unsigned char val) 
{
  mfp_timer_info *p = &mfp_timers[1] ;
  p->counter_value = val ;
  mfp.mfp_tbdr = val ;
}

void mfp_set_tcdr(unsigned char val) 
{
  mfp_timer_info *p = &mfp_timers[2] ;
  p->counter_value = val ;
  mfp.mfp_tcdr = val ;
}

void mfp_set_tddr(unsigned char val) 
{
  mfp_timer_info *p = &mfp_timers[3] ;
  p->counter_value = val ;
  mfp.mfp_tddr = val ;
}

static unsigned char mfp_get_tdr(int timer_num)
{
  mfp_timer_info *p = &mfp_timers[timer_num] ;
  if(p->period == 0 || p->divide == 0)
    stop_timer(timer_num) ;
  /* if timer is off */
  if(! p->timer_on) {
    return * (p->data_reg) ;
  } else {
    double now = get_atari_time() ;
    double fraction, decr ;
    fraction = (now - p->last_time) / (p->period * p->divide) ;
    decr = p->counter_value * fraction ;
    * (p->data_reg) = p->counter_value - decr +1 ;
    return * (p->data_reg) ;
  }
}



static void mfp_init_timers(void) {
  int i ;
  /* timers */
  for(i = 0 ; i < 3 ; i++) {
    struct mfp_timer_info *p =  &mfp_timers[i] ;
    p->timer_on = 0 ;
    p->alarm_on = 0;
  }
  mfp_timers[0].data_reg = &mfp.mfp_tadr ;
  mfp_timers[1].data_reg = &mfp.mfp_tbdr ;
  mfp_timers[2].data_reg = &mfp.mfp_tcdr ;
  mfp_timers[3].data_reg = &mfp.mfp_tddr ;
  usart_stop_timer_d();
}

static void mfp_reset_timers(void) {
  int i ;
  /* timers */
  for(i = 0 ; i < 3 ; i++) {
    struct mfp_timer_info *p =  &mfp_timers[i] ;
    p->timer_on = 0 ;
    p->alarm_on = 0;
  }
  clear_alarm_by_func(timer_alarm) ;
  mfp.mfp_tacr = 0;
  mfp.mfp_tbcr = 0;
  mfp.mfp_tcdcr = 0;
  usart_stop_timer_d();
}


unsigned char mfp_get_tacr(void) { return mfp.mfp_tacr ; }
unsigned char mfp_get_tbcr(void) { return mfp.mfp_tbcr ; }
unsigned char mfp_get_tcdcr(void) { return mfp.mfp_tcdcr ; }

unsigned char mfp_get_tadr(void) 
{
  return mfp_get_tdr(0) ;
}
unsigned char mfp_get_tbdr(void) 
{
  return 1 ;
  return mfp_get_tdr(1) ;
}
unsigned char mfp_get_tcdr(void) 
{
  return mfp_get_tdr(2) ;
}
unsigned char mfp_get_tddr(void) 
{
  return mfp_get_tdr(3) ;
}


/* usart stuff in usart.c */

